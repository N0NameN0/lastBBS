<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Exécution AJAX</title>
  </head>
  <body>
    <center><div id="myCanvas"></div></center>

    <script>
      // Load the bitmap font image
      const fontImage = new Image();
      const bgImage = new Image();

      // Promise pour attendre le chargement des deux images
      Promise.all([
        new Promise((resolve) => {
          fontImage.onload = resolve;
          fontImage.src = "img/ft.png";
        }),
        new Promise((resolve) => {
          bgImage.onload = resolve;
          bgImage.src = "img/bg.png";
        }),
      ]).then(() => {
        // Le reste du code s'exécute une fois les images chargées
        var NAME = "NoNameNo^WAB";

        // Create and setup canvas
        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        const canvasContainer = document.getElementById("myCanvas");

        const canvasBorderX = 16; // Taille de la bordure en pixels
        const canvasBorderY = 32; // Taille de la bordure en pixels
        let charWidth = 16; // Default character width
        let charHeight = 32; // Default character height

        // Set canvas size with border
        canvas.width = 80 * charWidth + canvasBorderX * 2; // Largeur + bordures gauche et droite
        canvas.height = 25 * charHeight + canvasBorderY * 2; // Hauteur + bordures haut et bas
        canvas.style.imageRendering = "pixelated"; // Keep pixel art sharp
        canvasContainer.appendChild(canvas);

        // Fill canvas with black background
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Ajouter une pile pour suivre les scripts en cours d'exécution
        let currentRunningScript = [];
        let files = [];
        let filePointers = [];

        let currentX = 1; // Position X de 1 à 80
        let currentY = 1; // Position Y de 1 à 25
        let savedX = 1; // Pour stocker la position X sauvegardée
        let savedY = 1; // Pour stocker la position Y sauvegardée
        let currentColor = 7; // Current text color index, 15 is white by default
        let currentBgColor = 0; // Current background color index, 0 is black by default

        let blinker = false;

        // Tableaux pour stocker les caractères et attributs
        let mychars = Array(25)
          .fill()
          .map(() => Array(80).fill(" "));
        let myattribs = Array(25)
          .fill()
          .map(() => Array(80).fill({ bg: 0, fg: 7 }));

        let keyQueue = [];
        let lastProcessedKey = "";
        let lastKeyPressTime = 0; // Add this line

        document.addEventListener("keydown", (event) => {
          event.preventDefault(); // Prevent default browser behavior
          const currentTime = Date.now();
          if (!keyQueue.includes(event.key) || currentTime - lastKeyPressTime > 200) {
            keyQueue.push(event.key);
            lastKeyPressTime = currentTime;
          }
        });

        document.addEventListener("keyup", (event) => {
          event.preventDefault(); // Prevent default browser behavior
          const index = keyQueue.indexOf(event.key);
          if (index > -1) {
            keyQueue.splice(index, 1);
          }
        });

        async function INKEY() {
          if (keyQueue.length > 0) {
            lastProcessedKey = keyQueue.shift(); // Change this line
            return lastProcessedKey;
          }
          await new Promise((resolve) => setTimeout(resolve, 50)); // Reduced delay for more responsiveness
          return "";
        }

        function CLS() {
          // Draw background color across entire canvas
          for (let y = 0; y < 25; y++) {
            for (let x = 0; x < 80; x++) {
              // Mise à jour des tableaux
              mychars[y][x] = " ";
              myattribs[y][x] = { bg: currentBgColor, fg: currentColor };

              // Dessin sur le canvas avec offset de 16 pixels
              ctx.drawImage(bgImage, currentBgColor * 16, 0, 16, 32, x * charWidth + canvasBorderX, y * charHeight + canvasBorderY, charWidth, charHeight);
            }
          }
          // Reset cursor position
          currentX = 1;
          currentY = 1;
        }

        function NEWLINE() {
          currentX = 1;
          currentY++;
          if (currentY > 25) {
            scrollup();
          }
        }

        function CLREOL() {
          // Calculate starting position
          const startX = (currentX - 1) * charWidth + canvasBorderX;
          const y = (currentY - 1) * charHeight + canvasBorderY;

          // Clear from current position to end of line
          for (let x = currentX - 1; x < 80; x++) {
            // Mise à jour des tableaux
            mychars[currentY - 1][x] = " ";
            myattribs[currentY - 1][x] = {
              bg: currentBgColor,
              fg: currentColor,
            };

            // Dessin sur le canvas
            ctx.drawImage(bgImage, currentBgColor * 16, 0, 16, 32, x * charWidth + canvasBorderX, y, charWidth, charHeight);
          }
        }

        function ANSIPOS(x, y) {
          if (x !== undefined && x !== null) {
            // Contraindre X entre 1 et 80
            currentX = Math.min(80, Math.max(1, Math.round(x)));
          }
          if (y !== undefined && y !== null) {
            // Contraindre Y entre 1 et 25
            currentY = Math.min(25, Math.max(1, Math.round(y)));
          }
        }

        function PRINT(str) {
          for (let i = 0; i < str.length; i++) {
            if (str[i] === "@") {
              if (str[i + 1] === "X" && i + 3 < str.length) {
                // Color change detected
                currentBgColor = parseInt(str[i + 2], 16);
                currentColor = parseInt(str[i + 3], 16);

                i += 3;
              } else if (str.substring(i, i + 6) === "@USER@") {
                // User tag detected
                PRINT(NAME);
                i += 5;
              } else {
                // Si @ n'est pas suivi de X ou de USER@, on l'affiche normalement
                drawChar("@", currentX, currentY);
                currentX++;
              }
            } else {
              // Check if we need to wrap to the next line
              if (currentX > 80) {
                currentX = 1;
                currentY++;
                if (currentY > 25) {
                  scrollup();
                }
              }

              drawChar(str[i], currentX, currentY);
              currentX++;
            }
          }
        }

        function PRINTLN(str) {
          PRINT(str);
          currentX = 1; // Reset à 1 (première colonne)
          currentY++; // Incrémente d'une ligne
          if (currentY > 25) {
            scrollup();
          }
        }

        function DELAY(val) {
          return new Promise((resolve) => {
            setTimeout(resolve, val * 100); // val * 100 car val est en dixièmes de seconde
          });
        }

        function GETX() {
          return currentX;
        }

        function GETY() {
          return currentY;
        }

        function RIGHT(str, len) {
          if (!str) return "";
          if (len <= 0) return "";
          if (len >= str.length) return str;
          return str.slice(-len);
        }

        function LEFT(str, len) {
          if (!str) return "";
          if (len <= 0) return "";
          if (len >= str.length) return str;
          return str.slice(0, len);
        }

        function LEN(str) {
          if (!str) return 0;
          return str.length;
        }

        function UPPER(str) {
          if (!str) return "";
          return str.toUpperCase();
        }

        // Nouvelle fonction NOCOLOR
        function NOCOLOR(str) {
          if (!str) return "";
          // Supprime tous les codes couleurs de format @Xnn
          return str.replace(/@X[0-9A-F][0-9A-F]/gi, "");
        }

        // Nouvelle fonction BACKUP
        function BACKUP(nb) {
          // S'assurer que nb est un entier positif
          nb = Math.max(0, Math.floor(nb));
          // Calculer la nouvelle position X sans aller en dessous de 1
          currentX = Math.max(1, currentX - nb);
        }

        // Nouvelle fonction FORWARD
        function FORWARD(nb) {
          // S'assurer que nb est un entier positif
          nb = Math.max(0, Math.floor(nb));
          // Calculer la nouvelle position X sans dépasser 80
          currentX = Math.min(80, currentX + nb);
        }

        // Nouvelle fonction COLOR
        function COLOR(col) {
          // S'assurer que la valeur est entre 0 et 15
          col = Math.max(0, Math.min(15, Math.floor(col)));
          currentColor = col;
        }
        function BGCOLOR(col) {
          // S'assurer que la valeur est entre 0 et 15
          col = Math.max(0, Math.min(15, Math.floor(col)));
          currentBgColor = col;
        }

        // Nouvelle fonction DEFCOLOR
        function DEFCOLOR() {
          // Réinitialiser aux couleurs par défaut
          currentBgColor = 0; // Noir
          currentColor = 7; // Gris clair
        }

        async function WAIT() {
          while (!INKEY()) {
            await new Promise((resolve) => setTimeout(resolve, 50)); // Reduced delay for more responsiveness
          }
        }

        // Nouvelle fonction SCRTEXT
        function SCRTEXT(x, y, len, code) {
          let result = "";
          let lastBg = -1;
          let lastFg = -1;

          for (let i = 0; i < len; i++) {
            if (x + i > 80) break; // Ne pas dépasser la largeur

            const char = mychars[y - 1][x + i - 1];
            const attrib = myattribs[y - 1][x + i - 1];

            if (code) {
              // Ajouter les codes couleur si nécessaire
              if (attrib.bg !== lastBg || attrib.fg !== lastFg) {
                result += `@X${attrib.bg.toString(16)}${attrib.fg.toString(16)}`;
                lastBg = attrib.bg;
                lastFg = attrib.fg;
              }
            }
            result += char;
          }

          return result;
        }

        function U_NAME() {
          return NAME;
        }

        async function FOPEN(index) {
          if (index < 1 || index > 5) {
            throw new Error("Index must be between 1 and 5");
          }

          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open("POST", "file_action.php", true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

            xhr.onload = function () {
              if (xhr.status === 200) {
                files[index] = {
                  content: xhr.responseText.split("\n"),
                  index: index,
                };
                filePointers[index] = 0;
                resolve();
              } else {
                reject(new Error("Failed to load file"));
              }
            };

            xhr.onerror = () => reject(new Error("Network error"));

            const currentScript = currentRunningScript[currentRunningScript.length - 1] || "unknown";

            const data = {
              action: "FOPEN",
              index: index,
              script: currentScript,
            };

            xhr.send(`data=${encodeURIComponent(JSON.stringify(data))}`);
          });
        }

        function FGET(index) {
          if (!files[index]) {
            throw new Error("File not opened");
          }

          if (filePointers[index] >= files[index].content.length) {
            return null;
          }

          const value = files[index].content[filePointers[index]++];

          // Si c'est un nombre, le convertir
          if (!isNaN(value)) {
            return Number(value);
          }

          // Si c'est une chaîne, supprimer uniquement CR et LF à la fin
          if (typeof value === "string") {
            return value.replace(/[\r\n]+$/, "");
          }

          return value;
        }

        function FCLOSE(index) {
          files[index] = null;
          filePointers[index] = 0;
        }

        async function FPUT(index, value) {
          if (!files[index]) {
            throw new Error("File not opened");
          }

          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open("POST", "file_action.php", true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

            xhr.onload = function () {
              if (xhr.status === 200) {
                resolve();
              } else {
                reject(new Error("Failed to write to file"));
              }
            };

            xhr.onerror = () => reject(new Error("Network error"));

            const currentScript = currentRunningScript[currentRunningScript.length - 1] || "unknown";

            const data = {
              action: "FPUT",
              index: index,
              value: value,
              script: currentScript,
              addCRLF: false,
            };

            xhr.send(`data=${encodeURIComponent(JSON.stringify(data))}`);
          });
        }

        async function FPUTLN(index, value) {
          if (!files[index]) {
            throw new Error("File not opened");
          }

          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open("POST", "file_action.php", true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

            xhr.onload = function () {
              if (xhr.status === 200) {
                resolve();
              } else {
                reject(new Error("Failed to write to file"));
              }
            };

            xhr.onerror = () => reject(new Error("Network error"));

            const currentScript = currentRunningScript[currentRunningScript.length - 1] || "unknown";

            const data = {
              action: "FPUT",
              index: index,
              value: value,
              script: currentScript,
              addCRLF: true,
            };

            xhr.send(`data=${encodeURIComponent(JSON.stringify(data))}`);
          });
        }

        function FSIZE(index) {
          if (!files[index]) {
            throw new Error("File not opened");
          }

          // Obtenir le contenu
          let content = files[index].content;

          // Si le tableau est vide, retourner 0
          if (content.length === 0) return 0;

          // Si la dernière ligne est vide, retourner la longueur - 1
          if (content[content.length - 1].trim() === "") {
            return content.length - 1;
          }

          // Sinon retourner la longueur totale
          return content.length;
        }

        // Nouvelle fonction DISPFILE
        async function DISPFILE(index) {
          try {
            await FOPEN(index);

            const size = FSIZE(index);
            // Lire et afficher chaque ligne
            for (let i = 0; i < size; i++) {
              const line = FGET(index);
              PRINTLN(line);
            }

            FCLOSE(index);
          } catch (error) {
            PRINTLN("@X0C Error reading file: " + error.message);
          }
        }

        // Nouvelle fonction SAVEPOS
        function SAVEPOS() {
          savedX = currentX;
          savedY = currentY;
        }

        // Nouvelle fonction RESTOREPOS
        function RESTOREPOS() {
          currentX = savedX;
          currentY = savedY;
        }

        //-------------------------
        //- Tools functions
        //-------------------------

        // Modifier loadAndRun pour gérer correctement la pile de scripts
        async function loadAndRun(scriptName) {
          return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            const nocache = "?_=" + Date.now();
            xhr.open("GET", scriptName + nocache, true);

            xhr.onload = function () {
              if (xhr.status === 200) {
                currentRunningScript.push(scriptName); // Empiler le script
                try {
                  // Utiliser une fonction asynchrone auto-exécutée pour attendre la fin
                  (async () => {
                    currentBgColor = 0;
                    currentColor = 7;
                    CLS();
                    await eval(xhr.responseText);
                    currentRunningScript.pop(); // Dépiler seulement après que tout soit fini
                    resolve(); // Résoudre la promesse une fois terminé
                  })();
                } catch (error) {
                  console.error("Error executing script:", error);
                  currentRunningScript.pop(); // Dépiler en cas d'erreur aussi
                  reject(error); // Rejeter la promesse en cas d'erreur
                }
              } else {
                console.error("Error loading the script:", xhr.statusText);
                reject(new Error(xhr.statusText));
              }
            };

            xhr.onerror = function () {
              console.error("Network error occurred");
              reject(new Error("Network error"));
            };

            xhr.send();
          });
        }

        function mapSpecialChar(char) {
          const charCode = char.charCodeAt(0);
          if (charCode > 32 && charCode < 128) {
            return charCode; // Return as-is for all characters 0-255
          }

          const specialChars = {
            // Unicode to CP737 mappings for common symbols
            "☺": 1,
            "☻": 2,
            "♥": 3,
            "♦": 4,
            "♣": 5,
            "♠": 6,
            "•": 7,
            "◘": 8,
            "○": 9,
            "◙": 10,
            "♂": 11,
            "♀": 12,
            "♪": 13,
            "♫": 14,
            "☼": 15,
            "►": 16,
            "◄": 17,
            "↕": 18,
            "‼": 19,
            "¶": 20,
            "§": 21,
            "▬": 22,
            "↨": 23,
            "↑": 24,
            "↓": 25,
            "→": 26,
            "←": 27,
            "∟": 28,
            "↔": 29,
            "▲": 30,
            "▼": 31,

            "⌂": 127,

            // Extended ASCII mappings (128-255)
            Ç: 128,
            ü: 129,
            é: 130,
            â: 131,
            ä: 132,
            à: 133,
            å: 134,
            ç: 135,
            ê: 136,
            ë: 137,
            è: 138,
            ï: 139,
            î: 140,
            ì: 141,
            Ä: 142,
            Å: 143,
            É: 144,
            æ: 145,
            Æ: 146,
            ô: 147,
            ö: 148,
            ò: 149,
            û: 150,
            ù: 151,
            ÿ: 152,
            Ö: 153,
            Ü: 154,
            "¢": 155,
            "£": 156,
            "¥": 157,
            "₧": 158,
            ƒ: 159,
            á: 160,
            í: 161,
            ó: 162,
            ú: 163,
            ñ: 164,
            Ñ: 165,
            ª: 166,
            º: 167,
            "¿": 168,
            "⌐": 169,
            "¬": 170,
            "½": 171,
            "¼": 172,
            "¡": 173,
            "«": 174,
            "»": 175,
            "░": 176,
            "▒": 177,
            "▓": 178,
            "│": 179,
            "┤": 180,
            "╡": 181,
            "╢": 182,
            "╖": 183,
            "╕": 184,
            "╣": 185,
            "║": 186,
            "╗": 187,
            "╝": 188,
            "╜": 189,
            "╛": 190,
            "┐": 191,
            "└": 192,
            "┴": 193,
            "┬": 194,
            "├": 195,
            "─": 196,
            "┼": 197,
            "╞": 198,
            "╟": 199,
            "╚": 200,
            "╔": 201,
            "╩": 202,
            "╦": 203,
            "╠": 204,
            "═": 205,
            "╬": 206,
            "╧": 207,
            "╨": 208,
            "╤": 209,
            "╥": 210,
            "╙": 211,
            "╘": 212,
            "╒": 213,
            "╓": 214,
            "╫": 215,
            "╪": 216,
            "┘": 217,
            "┌": 218,
            "█": 219,
            "▄": 220,
            "▌": 221,
            "▐": 222,
            "▀": 223,
            α: 224,
            ß: 225,
            Γ: 226,
            π: 227,
            Σ: 228,
            σ: 229,
            µ: 230,
            τ: 231,
            Φ: 232,
            Θ: 233,
            Ω: 234,
            δ: 235,
            "∞": 236,
            φ: 237,
            ε: 238,
            "∩": 239,
            "≡": 240,
            "±": 241,
            "≥": 242,
            "≤": 243,
            "⌠": 244,
            "⌡": 245,
            "÷": 246,
            "≈": 247,
            "°": 248,
            "∙": 249,
            "·": 250,
            "√": 251,
            ⁿ: 252,
            "²": 253,
            "■": 254,
            " ": 255,
          };

          return specialChars[char]; // Return space (32) if character is not found
        }

        // Modifier drawChar pour mettre à jour les tableaux
        function drawChar(char, x, y) {
          // Sauvegarder le caractère et ses attributs
          mychars[y - 1][x - 1] = char;
          myattribs[y - 1][x - 1] = { bg: currentBgColor, fg: currentColor };

          const charCode = mapSpecialChar(char);
          const sourceX = (charCode % 256) * charWidth;
          const sourceY = currentColor * charHeight;

          // Convert character positions to pixel positions with border offset
          const pixelX = (x - 1) * charWidth + canvasBorderX;
          const pixelY = (y - 1) * charHeight + canvasBorderY;

          // Draw background first
          ctx.drawImage(bgImage, currentBgColor * 16, 0, 16, 32, pixelX, pixelY, charWidth, charHeight);

          // Then draw the character
          ctx.drawImage(fontImage, sourceX, sourceY, charWidth, charHeight, pixelX, pixelY, charWidth, charHeight);
        }

        // Fonction pour faire clignoter le curseur
        function startBlinker() {
          setInterval(() => {
            blinker = !blinker; // Inverse la valeur de blinker
          }, 500); // Toutes les 500ms
        }

        function scrollup() {
          // Déplacer les caractères et les attributs d'une ligne vers le haut
          for (let y = 0; y < 24; y++) {
            for (let x = 0; x < 80; x++) {
              // Copier le caractère et les attributs de la ligne suivante
              mychars[y][x] = mychars[y + 1][x];
              myattribs[y][x] = myattribs[y + 1][x];

              // Redessiner avec les bons attributs
              const pixelX = x * charWidth + canvasBorderX;
              const pixelY = y * charHeight + canvasBorderY;

              // Dessiner le fond
              ctx.drawImage(bgImage, myattribs[y][x].bg * 16, 0, 16, 32, pixelX, pixelY, charWidth, charHeight);

              // Dessiner le caractère avec sa couleur
              const charCode = mapSpecialChar(mychars[y][x]);
              ctx.drawImage(fontImage, (charCode % 256) * charWidth, myattribs[y][x].fg * charHeight, charWidth, charHeight, pixelX, pixelY, charWidth, charHeight);
            }
          }

          // Effacer la dernière ligne
          for (let x = 0; x < 80; x++) {
            mychars[24][x] = " ";
            myattribs[24][x] = { bg: currentBgColor, fg: currentColor };
            drawChar(" ", x + 1, 25);
          }

          currentY = 25;
        }

        // Démarrer le clignotement immédiatement
        startBlinker();
        //----------------
        //----------------
        // RUN from here ;)
        //----------------
        //----------------
        // Exécuter les scripts de manière séquentielle
        (async () => {
          await loadAndRun("PPE/CIAONE20/index.js");
        })();
      });
    </script>
  </body>
</html>
